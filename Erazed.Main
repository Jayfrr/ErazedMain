local Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/Loco-CTO/UI-Library/main/VisionLibV2/source.lua'))()

Window = Library:Create({
	Name = "ERAZED",
	Footer = "By: Jay (jqdenfr)",
	ToggleKey = Enum.KeyCode.RightShift,
	LoadedCallback = function()
		Window:TaskBarOnly(true)
	end,
	KeySystem = true,
	Key = "Skibidi476384",
	MaxAttempts = 5,
	DiscordLink = nil,
	ToggledRelativeYOffset = 0
})

Window:ChangeTogglekey(Enum.KeyCode.RightShift)

local Tab = Window:Tab({
	Name = "Home",
	Icon = "rbxassetid://11396131982",
	Color = Color3.new(1, 0, 0)
})

local Section1 = Tab:Section({
	Name = "Legit"
})

local Button = Section1:Button({
	Name = "Silent Aim",
	Callback = function()    
		getgenv().AimPart = "Head" -- For R15 Games: {UpperTorso, LowerTorso, HumanoidRootPart, Head} | For R6 Games: {Head, Torso, HumanoidRootPart}
getgenv().AimlockToggleKey = "C" -- Toggles Aimbot On/Off 
getgenv().AimRadius = 50 -- How far away from someones character you want to lock on at
getgenv().TeamCheck = false -- Check if Target is on your Team (True means it wont lock onto your teamates, false is vice versa) (Set it to false if there are no teams)
getgenv().PredictMovement = true -- Predicts if they are moving in fast velocity (like jumping) so the aimbot will go a bit faster to match their speed 
getgenv().PredictionVelocity = 10 -- The speed of the PredictMovement feature 
 
getgenv().FuckHoodUniversalAimbotLoadingTime = tick()
if FuckHoodUniversalAimbotLoaded == true then
    Notify("FuckHood", "Script Loaded Already", "", 3)
    return 
end
 
local Players, Uis, RService, SGui = game:GetService"Players", game:GetService"UserInputService", game:GetService"RunService", game:GetService"StarterGui";
local Client, Mouse, Camera, CF, RNew, Vec3, Vec2 = Players.LocalPlayer, Players.LocalPlayer:GetMouse(), workspace.CurrentCamera, CFrame.new, Ray.new, Vector3.new, Vector2.new;
local Aimlock, MousePressed, CanNotify = true, false, false;
local AimlockTarget;
getgenv().FuckHoodUniversalAimbotLoaded = true
 
getgenv().SeparateNotify = function(title, text, icon, time) 
    SGui:SetCore("SendNotification",{
        Title = title;
        Text = text;
        Icon = "";
        Duration = time;
    })
end
 
getgenv().Notify = function(title, text, icon, time)
    if CanNotify == true then 
        if not time or not type(time) == "number" then time = 3 end
        SGui:SetCore("SendNotification",{
            Title = title;
            Text = text;
            Icon = "";
            Duration = time;
        }) 
    end
end
getgenv().ThirdPerson = true -- Locking onto someone in your Third Person POV
getgenv().FirstPerson = true 
getgenv().WorldToViewportPoint = function(P)
    return Camera:WorldToViewportPoint(P)
end
 
getgenv().WorldToScreenPoint = function(P)
    return Camera.WorldToScreenPoint(Camera, P)
end
 
getgenv().GetObscuringObjects = function(T)
    if T and T:FindFirstChild(getgenv().AimPart) and Client and Client.Character:FindFirstChild("Head") then 
        local RayPos = workspace:FindPartOnRay(RNew(
            T[getgenv().AimPart].Position, Client.Character.Head.Position)
        )
        if RayPos then return RayPos:IsDescendantOf(T) end
    end
end
 
getgenv().GetNearestTarget = function()
    -- Credits to whoever made this, i didnt make it, and my own mouse2plr function kinda sucks
    local players = {}
    local PLAYER_HOLD  = {}
    local DISTANCES = {}
    for i, v in pairs(Players:GetPlayers()) do
        if v ~= Client then
            table.insert(players, v)
        end
    end
    for i, v in pairs(players) do
        if v.Character ~= nil then
            local AIM = v.Character:FindFirstChild("Head")
            if getgenv().TeamCheck == true and v.Team ~= Client.Team then
                local DISTANCE = (v.Character:FindFirstChild("Head").Position - game.Workspace.CurrentCamera.CFrame.p).magnitude
                local RAY = Ray.new(game.Workspace.CurrentCamera.CFrame.p, (Mouse.Hit.p - game.Workspace.CurrentCamera.CFrame.p).unit * DISTANCE)
                local HIT,POS = game.Workspace:FindPartOnRay(RAY, game.Workspace)
                local DIFF = math.floor((POS - AIM.Position).magnitude)
                PLAYER_HOLD[v.Name .. i] = {}
                PLAYER_HOLD[v.Name .. i].dist= DISTANCE
                PLAYER_HOLD[v.Name .. i].plr = v
                PLAYER_HOLD[v.Name .. i].diff = DIFF
                table.insert(DISTANCES, DIFF)
            elseif getgenv().TeamCheck == false and v.Team == Client.Team then 
                local DISTANCE = (v.Character:FindFirstChild("Head").Position - game.Workspace.CurrentCamera.CFrame.p).magnitude
                local RAY = Ray.new(game.Workspace.CurrentCamera.CFrame.p, (Mouse.Hit.p - game.Workspace.CurrentCamera.CFrame.p).unit * DISTANCE)
                local HIT,POS = game.Workspace:FindPartOnRay(RAY, game.Workspace)
                local DIFF = math.floor((POS - AIM.Position).magnitude)
                PLAYER_HOLD[v.Name .. i] = {}
                PLAYER_HOLD[v.Name .. i].dist= DISTANCE
                PLAYER_HOLD[v.Name .. i].plr = v
                PLAYER_HOLD[v.Name .. i].diff = DIFF
                table.insert(DISTANCES, DIFF)
            end
        end
    end
 
    if unpack(DISTANCES) == nil then
        return nil
    end
 
    local L_DISTANCE = math.floor(math.min(unpack(DISTANCES)))
    if L_DISTANCE > getgenv().AimRadius then
        return nil
    end
 
    for i, v in pairs(PLAYER_HOLD) do
        if v.diff == L_DISTANCE then
            return v.plr
        end
    end
    return nil
end
 
--[[getgenv().CheckTeamsChildren = function()
    if workspace and workspace:FindFirstChild"Teams" then 
        if getgenv().TeamCheck == true then
            if #workspace.Teams:GetChildren() == 0 then 
                getgenv().TeamCheck = false 
                SeparateNotify("FuckHood", "TeamCheck set to: "..tostring(getgenv().TeamCheck).." because there are no teams!", "", 3)
            end
        end
    end
end
CheckTeamsChildren()
]]--
 
--[[getgenv().GetNearestTarget = function()
    local T;
    for _, p in next, Players:GetPlayers() do 
        if p ~= Client then 
            if p.Character and p.Character:FindFirstChild(getgenv().AimPart) then 
                if getgenv().TeamCheck == true and p.Team ~= Client.Team then 
                    local Pos, ScreenCheck = WorldToScreenPoint(p.Character[getgenv().AimPart].Position)
                    Pos = Vec2(Pos.X, Pos.Y)
                    local MPos = Vec2(Mouse.X, Mouse.Y) -- Credits to CriShoux for this
                    local Distance = (Pos - MPos).Magnitude;
                    if Distance < getgenv().AimRadius then 
                        T = p 
                    end
                elseif getgenv().TeamCheck == false and p.Team == Client.Team then 
                    local Pos, ScreenCheck = WorldToScreenPoint(p.Character[getgenv().AimPart].Position)
                    Pos = Vec2(Pos.X, Pos.Y)
                    local MPos = Vec2(Mouse.X, Mouse.Y) -- Credits to CriShoux for this
                    local Distance = (Pos - MPos).Magnitude;
                    if Distance < getgenv().AimRadius then 
                        T = p 
                    end
                end
            end
        end
    end
    if T then 
        return T
    end
end]]--
 
Uis.InputBegan:Connect(function(Key)
    if not (Uis:GetFocusedTextBox()) then 
        if Key.UserInputType == Enum.UserInputType.MouseButton2 then 
            pcall(function()
                if MousePressed ~= true then MousePressed = true end 
                local Target;Target = GetNearestTarget()
                if Target ~= nil then 
                    AimlockTarget = Target
 
                end
            end)
        end
        if Key.KeyCode == Enum.KeyCode[AimlockToggleKey] then 
            Aimlock = not Aimlock
 
        end
    end
end)
Uis.InputEnded:Connect(function(Key)
    if not (Uis:GetFocusedTextBox()) then 
        if Key.UserInputType == Enum.UserInputType.MouseButton2 then 
            if AimlockTarget ~= nil then AimlockTarget = nil end
            if MousePressed ~= false then 
                MousePressed = false 
            end
        end
    end
end)
 
RService.RenderStepped:Connect(function()
CanNotify = true
    if Aimlock == true and MousePressed == true then 
        if AimlockTarget and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(getgenv().AimPart) then 
            if getgenv().FirstPerson == true and getgenv().ThirdPerson == true then
                if CanNotify == true then
                    if getgenv().PredictMovement == true then 
                        Camera.CFrame = CF(Camera.CFrame.p, AimlockTarget.Character[getgenv().AimPart].Position + AimlockTarget.Character[getgenv().AimPart].Velocity/PredictionVelocity)
                    elseif getgenv().PredictMovement == false then 
                        Camera.CFrame = CF(Camera.CFrame.p, AimlockTarget.Character[getgenv().AimPart].Position)
                    end
                end
            end
        end
    end
end)
 
		Library:Notify({
			Name = "Silent Aim",
			Text = "C To Toggle The Lock",
			Icon = "rbxassetid://11401835376",
			Duration = 5
		})
	end
})


local Section2 = Tab:Section({
	Name = "Movement"
})


local Tab = Window:Tab({
	Name = "UI",
	Icon = "rbxassetid://11476626403",
	Color = Color3.new(1, 0, 0)
})




local Button = Section2:Button({
	Name = "X Fly",
	Callback = function()
        local plr = game.Players.LocalPlayer
local mouse = plr:GetMouse()

localplayer = plr

if workspace:FindFirstChild("Core") then
workspace.Core:Destroy()
end

local Core = Instance.new("Part")
Core.Name = "Core"
Core.Size = Vector3.new(0.05, 0.05, 0.05)

spawn(function()
Core.Parent = workspace
local Weld = Instance.new("Weld", Core)
Weld.Part0 = Core
Weld.Part1 = localplayer.Character.LowerTorso
Weld.C0 = CFrame.new(0, 0, 0)
end)

workspace:WaitForChild("Core")

local torso = workspace.Core
flying = true
local speed=10
local keys={a=false,d=false,w=false,s=false}
local e1
local e2
local function start()
local pos = Instance.new("BodyPosition",torso)
local gyro = Instance.new("BodyGyro",torso)
pos.Name="EPIXPOS"
pos.maxForce = Vector3.new(math.huge, math.huge, math.huge)
pos.position = torso.Position
gyro.maxTorque = Vector3.new(9e9, 9e9, 9e9)
gyro.cframe = torso.CFrame
repeat
wait()
localplayer.Character.Humanoid.PlatformStand=true
local new=gyro.cframe - gyro.cframe.p + pos.position
if not keys.w and not keys.s and not keys.a and not keys.d then
speed=5
end
if keys.w then
new = new + workspace.CurrentCamera.CoordinateFrame.lookVector * speed
speed=speed+0
end
if keys.s then
new = new - workspace.CurrentCamera.CoordinateFrame.lookVector * speed
speed=speed+0
end
if keys.d then
new = new * CFrame.new(speed,0,0)
speed=speed+0
end
if keys.a then
new = new * CFrame.new(-speed,0,0)
speed=speed+0
end
if speed>10 then
speed=5
end
pos.position=new.p
if keys.w then
gyro.cframe = workspace.CurrentCamera.CoordinateFrame*CFrame.Angles(-math.rad(speed*0),0,0)
elseif keys.s then
gyro.cframe = workspace.CurrentCamera.CoordinateFrame*CFrame.Angles(math.rad(speed*0),0,0)
else
gyro.cframe = workspace.CurrentCamera.CoordinateFrame
end
until flying == false
if gyro then gyro:Destroy() end
if pos then pos:Destroy() end
flying=false
localplayer.Character.Humanoid.PlatformStand=false
speed=10
end
e1=mouse.KeyDown:connect(function(key)
if not torso or not torso.Parent then flying=false e1:disconnect() e2:disconnect() return end
if key=="w" then
keys.w=true
elseif key=="s" then
keys.s=true
elseif key=="a" then
keys.a=true
elseif key=="d" then
keys.d=true
elseif key=="x" then
if flying==true then
flying=false
else
flying=true
start()
end
end
end)
e2=mouse.KeyUp:connect(function(key)
if key=="w" then
keys.w=false
elseif key=="s" then
keys.s=false
elseif key=="a" then
keys.a=false
elseif key=="d" then
keys.d=false
end
end)
start()

		Dropdown:AddItem("Item")
	end
})

Library:Notify({
	Name = "",
	Text = "",
	Icon = "rbxassetid://11401835376",
	Duration = 3,
	Callback = function()
		Library:Notify({
			Name = "",
			Text = "Notify Callback",
			Icon = "rbxassetid://11401835376",
			Duration = 3,
		})
	end
})




local SettingsSection = Tab:Section({
	Name = "Miscs"
})

local Button = SettingsSection:Button({
	Name = "Destroy library",
	Callback = function()
		Library:Destroy()
	end
})


local Button = SettingsSection:Button({
	Name = "Task Bar Only",
	Callback = function()
		Window:TaskBarOnly(true)

		task.wait(3)

		Window:TaskBarOnly(false)
	end
})

local Keybind = SettingsSection:Keybind({
    Name = "Toggle keybind",
    Default = Enum.KeyCode.Return,
    Callback = function() return end,
    UpdateKeyCallback = function(Key)
		task.wait(0.1)
        Window:ChangeTogglekey(Key)
    end
})

local PlayerTab = Window:Tab({
	Name = "Player",
	Icon = "rbxassetid://11396131982",
	Color = Color3.new(1, 0, 0)
})


local Section3 = PlayerTab:Section({
	Name = "ESP"
})



local Button = Section3:Button({
	Name = "Rig ESP",
	Callback = function()
        local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Blissful4992/ESPs/main/UniversalSkeleton.lua"))()


local Skeletons = {}
for _, Player in next, game.Players:GetChildren() do
    table.insert(Skeletons, Library:NewSkeleton(Player, true));
end
game.Players.PlayerAdded:Connect(function(Player)
    table.insert(Skeletons, Library:NewSkeleton(Player, true));
end)
		Library:Notify({
			Name = "Button",
			Text = "Clicked",
			Icon = "rbxassetid://11401835376",
			Duration = 3
		})
	end
})



local Button = Section3:Button({
	Name = "Box ESP",
	Callback = function()
        local Settings = {
            Box_Color = Color3.fromRGB(255, 0, 0),
            Tracer_Color = Color3.fromRGB(255, 0, 0),
            Tracer_Thickness = 1,
            Box_Thickness = 1,
            Tracer_Origin = "Bottom", -- Middle or Bottom if FollowMouse is on this won't matter...
            Tracer_FollowMouse = false,
            Tracers = false
        }
        local Team_Check = {
            TeamCheck = false, -- if TeamColor is on this won't matter...
            Green = Color3.fromRGB(0, 255, 0),
            Red = Color3.fromRGB(255, 0, 0)
        }
        local TeamColor = true
        
        --// SEPARATION
        local player = game:GetService("Players").LocalPlayer
        local camera = game:GetService("Workspace").CurrentCamera
        local mouse = player:GetMouse()
        
        local function NewQuad(thickness, color)
            local quad = Drawing.new("Quad")
            quad.Visible = false
            quad.PointA = Vector2.new(0,0)
            quad.PointB = Vector2.new(0,0)
            quad.PointC = Vector2.new(0,0)
            quad.PointD = Vector2.new(0,0)
            quad.Color = color
            quad.Filled = false
            quad.Thickness = thickness
            quad.Transparency = 1
            return quad
        end
        
        local function NewLine(thickness, color)
            local line = Drawing.new("Line")
            line.Visible = false
            line.From = Vector2.new(0, 0)
            line.To = Vector2.new(0, 0)
            line.Color = color 
            line.Thickness = thickness
            line.Transparency = 1
            return line
        end
        
        local function Visibility(state, lib)
            for u, x in pairs(lib) do
                x.Visible = state
            end
        end
        
        local function ToColor3(col) --Function to convert, just cuz c;
            local r = col.r --Red value
            local g = col.g --Green value
            local b = col.b --Blue value
            return Color3.new(r,g,b); --Color3 datatype, made of the RGB inputs
        end
        
        local black = Color3.fromRGB(0, 0 ,0)
        local function ESP(plr)
            local library = {
                --//Tracer and Black Tracer(black border)
                blacktracer = NewLine(Settings.Tracer_Thickness*2, black),
                tracer = NewLine(Settings.Tracer_Thickness, Settings.Tracer_Color),
                --//Box and Black Box(black border)
                black = NewQuad(Settings.Box_Thickness*2, black),
                box = NewQuad(Settings.Box_Thickness, Settings.Box_Color),
                --//Bar and Green Health Bar (part that moves up/down)
                healthbar = NewLine(3, black),
                greenhealth = NewLine(1.5, black)
            }
        
            local function Colorize(color)
                for u, x in pairs(library) do
                    if x ~= library.healthbar and x ~= library.greenhealth and x ~= library.blacktracer and x ~= library.black then
                        x.Color = color
                    end
                end
            end
        
            local function Updater()
                local connection
                connection = game:GetService("RunService").RenderStepped:Connect(function()
                    if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") ~= nil then
                        local HumPos, OnScreen = camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                        if OnScreen then
                            local head = camera:WorldToViewportPoint(plr.Character.Head.Position)
                            local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)
                            
                            local function Size(item)
                                item.PointA = Vector2.new(HumPos.X + DistanceY, HumPos.Y - DistanceY*2)
                                item.PointB = Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2)
                                item.PointC = Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)
                                item.PointD = Vector2.new(HumPos.X + DistanceY, HumPos.Y + DistanceY*2)
                            end
                            Size(library.box)
                            Size(library.black)
        
                            --//Tracer 
                            if Settings.Tracers then
                                if Settings.Tracer_Origin == "Middle" then
                                    library.tracer.From = camera.ViewportSize*0.5
                                    library.blacktracer.From = camera.ViewportSize*0.5
                                elseif Settings.Tracer_Origin == "Bottom" then
                                    library.tracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y) 
                                    library.blacktracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y)
                                end
                                if Settings.Tracer_FollowMouse then
                                    library.tracer.From = Vector2.new(mouse.X, mouse.Y+36)
                                    library.blacktracer.From = Vector2.new(mouse.X, mouse.Y+36)
                                end
                                library.tracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                                library.blacktracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                            else 
                                library.tracer.From = Vector2.new(0, 0)
                                library.blacktracer.From = Vector2.new(0, 0)
                                library.tracer.To = Vector2.new(0, 0)
                                library.blacktracer.To = Vector2.new(0, 02)
                            end
        
                            --// Health Bar
                            local d = (Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2) - Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)).magnitude 
                            local healthoffset = plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth * d
        
                            library.greenhealth.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                            library.greenhealth.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2 - healthoffset)
        
                            library.healthbar.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                            library.healthbar.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y - DistanceY*2)
        
                            local green = Color3.fromRGB(0, 255, 0)
                            local red = Color3.fromRGB(255, 0, 0)
        
                            library.greenhealth.Color = red:lerp(green, plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth);
        
                            if Team_Check.TeamCheck then
                                if plr.TeamColor == player.TeamColor then
                                    Colorize(Team_Check.Green)
                                else 
                                    Colorize(Team_Check.Red)
                                end
                            else 
                                library.tracer.Color = Settings.Tracer_Color
                                library.box.Color = Settings.Box_Color
                            end
                            if TeamColor == true then
                                Colorize(plr.TeamColor.Color)
                            end
                            Visibility(true, library)
                        else 
                            Visibility(false, library)
                        end
                    else 
                        Visibility(false, library)
                        if game.Players:FindFirstChild(plr.Name) == nil then
                            connection:Disconnect()
                        end
                    end
                end)
            end
            coroutine.wrap(Updater)()
        end
        
        for i, v in pairs(game:GetService("Players"):GetPlayers()) do
            if v.Name ~= player.Name then
                coroutine.wrap(ESP)(v)
            end
        end
        
        game.Players.PlayerAdded:Connect(function(newplr)
            if newplr.Name ~= player.Name then
                coroutine.wrap(ESP)(newplr)
            end
        end)
		Library:Notify({
			Name = "Info",
			Text = "Box ESP Enabled",
			Icon = "rbxassetid://11401835376",
			Duration = 3
		})
	end
})







local Button = Section3:Button({
	Name = "Tracer ESP",
	Callback = function()
        local Settings = {
            Box_Color = Color3.fromRGB(255, 0, 0),
            Tracer_Color = Color3.fromRGB(255, 0, 0),
            Tracer_Thickness = 1,
            Box_Thickness = 1,
            Tracer_Origin = "Bottom", -- Middle or Bottom if FollowMouse is on this won't matter...
            Tracer_FollowMouse = false,
            Tracers = true
        }
        local Team_Check = {
            TeamCheck = false, -- if TeamColor is on this won't matter...
            Green = Color3.fromRGB(0, 255, 0),
            Red = Color3.fromRGB(255, 0, 0)
        }
        local TeamColor = true
        
        --// SEPARATION
        local player = game:GetService("Players").LocalPlayer
        local camera = game:GetService("Workspace").CurrentCamera
        local mouse = player:GetMouse()
        
        local function NewQuad(thickness, color)
            local quad = Drawing.new("Quad")
            quad.Visible = false
            quad.PointA = Vector2.new(0,0)
            quad.PointB = Vector2.new(0,0)
            quad.PointC = Vector2.new(0,0)
            quad.PointD = Vector2.new(0,0)
            quad.Color = color
            quad.Filled = false
            quad.Thickness = thickness
            quad.Transparency = 1
            return quad
        end
        
        local function NewLine(thickness, color)
            local line = Drawing.new("Line")
            line.Visible = false
            line.From = Vector2.new(0, 0)
            line.To = Vector2.new(0, 0)
            line.Color = color 
            line.Thickness = thickness
            line.Transparency = 1
            return line
        end
        
        local function Visibility(state, lib)
            for u, x in pairs(lib) do
                x.Visible = state
            end
        end
        
        local function ToColor3(col) --Function to convert, just cuz c;
            local r = col.r --Red value
            local g = col.g --Green value
            local b = col.b --Blue value
            return Color3.new(r,g,b); --Color3 datatype, made of the RGB inputs
        end
        
        local black = Color3.fromRGB(0, 0 ,0)
        local function ESP(plr)
            local library = {
                --//Tracer and Black Tracer(black border)
                blacktracer = NewLine(Settings.Tracer_Thickness*2, black),
                tracer = NewLine(Settings.Tracer_Thickness, Settings.Tracer_Color),
                --//Box and Black Box(black border)
                black = NewQuad(Settings.Box_Thickness*2, black),
                box = NewQuad(Settings.Box_Thickness, Settings.Box_Color),
                --//Bar and Green Health Bar (part that moves up/down)
                healthbar = NewLine(3, black),
                greenhealth = NewLine(1.5, black)
            }
        
            local function Colorize(color)
                for u, x in pairs(library) do
                    if x ~= library.healthbar and x ~= library.greenhealth and x ~= library.blacktracer and x ~= library.black then
                        x.Color = color
                    end
                end
            end
        
            local function Updater()
                local connection
                connection = game:GetService("RunService").RenderStepped:Connect(function()
                    if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") ~= nil then
                        local HumPos, OnScreen = camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                        if OnScreen then
                            local head = camera:WorldToViewportPoint(plr.Character.Head.Position)
                            local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)
                            
                            local function Size(item)
                                item.PointA = Vector2.new(HumPos.X + DistanceY, HumPos.Y - DistanceY*2)
                                item.PointB = Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2)
                                item.PointC = Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)
                                item.PointD = Vector2.new(HumPos.X + DistanceY, HumPos.Y + DistanceY*2)
                            end
                            Size(library.box)
                            Size(library.black)
        
                            --//Tracer 
                            if Settings.Tracers then
                                if Settings.Tracer_Origin == "Middle" then
                                    library.tracer.From = camera.ViewportSize*0.5
                                    library.blacktracer.From = camera.ViewportSize*0.5
                                elseif Settings.Tracer_Origin == "Bottom" then
                                    library.tracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y) 
                                    library.blacktracer.From = Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y)
                                end
                                if Settings.Tracer_FollowMouse then
                                    library.tracer.From = Vector2.new(mouse.X, mouse.Y+36)
                                    library.blacktracer.From = Vector2.new(mouse.X, mouse.Y+36)
                                end
                                library.tracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                                library.blacktracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                            else 
                                library.tracer.From = Vector2.new(0, 0)
                                library.blacktracer.From = Vector2.new(0, 0)
                                library.tracer.To = Vector2.new(0, 0)
                                library.blacktracer.To = Vector2.new(0, 02)
                            end
        
                            --// Health Bar
                            local d = (Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2) - Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)).magnitude 
                            local healthoffset = plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth * d
        
                            library.greenhealth.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                            library.greenhealth.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2 - healthoffset)
        
                            library.healthbar.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                            library.healthbar.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y - DistanceY*2)
        
                            local green = Color3.fromRGB(0, 255, 0)
                            local red = Color3.fromRGB(255, 0, 0)
        
                            library.greenhealth.Color = red:lerp(green, plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth);
        
                            if Team_Check.TeamCheck then
                                if plr.TeamColor == player.TeamColor then
                                    Colorize(Team_Check.Green)
                                else 
                                    Colorize(Team_Check.Red)
                                end
                            else 
                                library.tracer.Color = Settings.Tracer_Color
                                library.box.Color = Settings.Box_Color
                            end
                            if TeamColor == true then
                                Colorize(plr.TeamColor.Color)
                            end
                            Visibility(true, library)
                        else 
                            Visibility(false, library)
                        end
                    else 
                        Visibility(false, library)
                        if game.Players:FindFirstChild(plr.Name) == nil then
                            connection:Disconnect()
                        end
                    end
                end)
            end
            coroutine.wrap(Updater)()
        end
        
        for i, v in pairs(game:GetService("Players"):GetPlayers()) do
            if v.Name ~= player.Name then
                coroutine.wrap(ESP)(v)
            end
        end
        
        game.Players.PlayerAdded:Connect(function(newplr)
            if newplr.Name ~= player.Name then
                coroutine.wrap(ESP)(newplr)
            end
        end)
		Library:Notify({
			Name = "Info",
			Text = "Tracers Enabled",
			Icon = "rbxassetid://11401835376",
			Duration = 3
		})
	end
})
